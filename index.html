<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HackerNet Terminal</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: #00ff00;
      font-family: 'Courier New', Courier, monospace;
      overflow-x: hidden;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }
    .container {
      position: relative;
      z-index: 1;
      padding: 2rem;
    }
    .card {
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #00ff00;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem auto;
      max-width: 700px;
      box-shadow: 0 0 15px #00ff00;
    }
    h2 {
      color: #0f0;
      border-bottom: 1px dashed #0f0;
      padding-bottom: 0.5rem;
    }
    .info {
      font-size: 1.1rem;
      margin-top: 0.5rem;
      color: #0f0;
    }
    .status-online { color: #0f0; }
    .status-offline { color: #f00; }
    #log {
      height: 150px;
      overflow-y: auto;
      font-size: 0.95rem;
      background-color: #000;
      border: 1px dashed #0f0;
      padding: 10px;
    }
  </style>
</head>
<body>
<div id="boot-sequence" style="background:black;color:#0f0;font-family:monospace;padding:20px;position:fixed;width:100%;height:100%;z-index:999;background:black;">
  <pre id="boot-log">[BOOTING] Initializing HackerNet Core...
[OK] Matrix grid activated...
[OK] Protocol stack loaded...
[OK] Access control bypassed...
[OK] Terminal interface online...
</pre>
  <div style="color:#0f0;">ComDotKKH is loading<span id="dots">.</span></div>
</div>
<script>
  let dots = document.getElementById('dots');
  let count = 0;
  setInterval(() => {
    dots.innerText = '.'.repeat((count++ % 3) + 1);
  }, 500);

  setTimeout(() => {
    document.getElementById('boot-sequence').style.display = 'none';
  }, 4000);
</script>
<canvas id="matrix"></canvas>
<div class="container">
  <div class="card">
    <h2>[Connection Status]</h2>
    <p id="connection-status" class="info">Checking...</p>
  </div>
  <div class="card">
    <h2>[Public IP Address]</h2>
    <p id="public-ip" class="info">Loading...</p>
  </div>
  <div class="card">
    <h2>[Local IP Address]</h2>
    <p id="local-ip" class="info">Loading...</p>
  </div>
  <div class="card">
    <h2>[Network Type]</h2>
    <p id="network-type" class="info">Detecting...</p>
  </div>
  <div class="card">
    <h2>[Internet Protocol]</h2>
    <p id="protocol" class="info">Checking...</p>
  </div>
  <div class="card">
    <h2>[Connection Type]</h2>
    <p id="connection-type" class="info">Detecting...</p>
  </div>
  <div class="card">
    <h2>[Device Info]</h2>
    <p class="info" id="device-info"></p>
  </div>
  <div class="card">
    <h2>[Access Log]</h2>
    <div id="log"></div>
  </div>
</div>

<script>
  // Matrix background
  const canvas = document.getElementById('matrix');
  const ctx = canvas.getContext('2d');
  canvas.height = window.innerHeight;
  canvas.width = window.innerWidth;
  const letters = '01'.split('');
  const fontSize = 14;
  const columns = canvas.width / fontSize;
  const drops = Array.from({ length: columns }).fill(1);
  function drawMatrix() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#0f0';
    ctx.font = fontSize + 'px Courier New';
    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);
      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
      drops[i]++;
    }
  }
  
// Add sparks and random flickering points
let sparks = [];
for (let i = 0; i < 100; i++) {
  sparks.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    r: Math.random() * 1.5 + 0.5
  });
}

function drawSparks() {
  ctx.fillStyle = '#0f0';
  for (let s of sparks) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI);
    ctx.fill();
    s.x += (Math.random() - 0.5) * 0.5;
    s.y += (Math.random() - 0.5) * 0.5;
    if (s.x < 0) s.x = canvas.width;
    if (s.x > canvas.width) s.x = 0;
    if (s.y < 0) s.y = canvas.height;
    if (s.y > canvas.height) s.y = 0;
  }
}

const oldDrawMatrix = drawMatrix;
function drawMatrixWrapper() {
  oldDrawMatrix();
  drawSparks();
}
setInterval(drawMatrixWrapper, 33);


  function updateConnectionStatus() {
    const status = navigator.onLine ? "Online" : "Offline";
    const statusEl = document.getElementById("connection-status");
    statusEl.textContent = status;
    statusEl.className = "info " + (navigator.onLine ? "status-online" : "status-offline");
  }

  async function updatePublicIP() {
    try {
      const res = await fetch("https://api.ipify.org?format=json");
      const data = await res.json();
      const ip = data.ip;
      document.getElementById("public-ip").textContent = ip;
      const proto = ip.includes(":") ? "IPv6" : "IPv4";
      const secure = window.location.protocol === "https:" ? "HTTPS" : "HTTP";
      document.getElementById("protocol").textContent = secure + " / " + proto;
      logAccess("Public IP updated: " + ip);
    } catch {
      document.getElementById("public-ip").textContent = "Failed to fetch";
      document.getElementById("protocol").textContent = "Unavailable";
    }
  }

  function getLocalIP(callback) {
    let pc = new RTCPeerConnection({iceServers:[]});
    pc.createDataChannel("");
    pc.createOffer().then(offer => pc.setLocalDescription(offer));
    pc.onicecandidate = (ice) => {
      if (ice && ice.candidate && ice.candidate.candidate) {
        const parts = ice.candidate.candidate.split(" ");
        const ip = parts[4];
        if (ip && ip !== "0.0.0.0") {
          callback(ip);
          pc.close();
        }
      }
    };
  }

  function updateLocalIP() {
    getLocalIP(ip => {
      document.getElementById("local-ip").textContent = ip;
      logAccess("Local IP updated: " + ip);
    });
  }

  function updateConnectionDetails() {
    const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    if (conn) {
      const type = conn.effectiveType || "Unknown";
      const connType = conn.type || "";
      document.getElementById("network-type").textContent = type.toUpperCase();
      let label = "Unknown";
      if (connType === "wifi" || type.includes("wifi")) {
        label = "WiFi";
      } else if (connType === "cellular" || type.includes("cellular") || type.includes("4g") || type.includes("3g") || type.includes("5g")) {
        label = "Mobile Data";
      }
      document.getElementById("connection-type").textContent = label;
      logAccess("Network updated: " + label + " (" + type + ")");
    } else {
      document.getElementById("network-type").textContent = "Not supported";
      document.getElementById("connection-type").textContent = "Unavailable";
    }
  }

  function updateDeviceInfo() {
    const ua = navigator.userAgent;
    const platform = navigator.platform;
    const lang = navigator.language;
    document.getElementById("device-info").textContent = 
      `UA: ${ua} | Platform: ${platform} | Language: ${lang}`;
  }

  function logAccess(text) {
    const logEl = document.getElementById("log");
    const time = new Date().toLocaleTimeString();
    logEl.innerHTML += `[${time}] ${text}<br>`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function updateAll() {
    updateConnectionStatus();
    updatePublicIP();
    updateLocalIP();
    updateConnectionDetails();
    updateDeviceInfo();
  }

  window.addEventListener("online", updateAll);
  window.addEventListener("offline", updateAll);
  if (navigator.connection) {
    navigator.connection.addEventListener("change", updateAll); navigator.connection.addEventListener("typechange", updateAll);
  }

  updateAll();
  setInterval(updateAll, 5000);
</script>
</body>
</html>
